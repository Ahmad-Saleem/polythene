{"version":3,"file":"polythene-core-tabs.js","sources":["../src/vars.js","../../polythene-css-classes/tabs.js","../../polythene-css-classes/button.js","../src/tabs.js","../src/tab.js","../src/scroll-button.js"],"sourcesContent":["import { vars } from \"polythene-theme\";\nimport { vars as buttonVars } from \"polythene-core-button\";\nimport { vars as iconButtonVars } from \"polythene-core-icon-button\";\n\nconst rgba = (colorStr, opacity = 1) =>\n  `rgba(${colorStr}, ${opacity})`;\n\nconst fontSize = buttonVars.font_size;\nconst tab_label_line_height = 1.1 * fontSize;\n\nexport default {\n  tab_min_width:                    72,\n  tab_max_width:                    \"initial\",\n  tab_height:                       48,\n  // tab_min_width_tablet:             160,\n  label_max_width:                  264,\n  menu_tab_height:                  44,\n  menu_tab_icon_label_height:       44,\n  tab_icon_label_height:            72,\n  tab_icon_label_icon_spacing:      7,\n  indicator_slide_speed:            600, // px per second\n  indicator_slide_min_duration:     .250,\n  tabs_indent:                      vars.unit_indent,\n  tabs_scroll_speed:                600, // px per second\n  tabs_scroll_delay:                .15,\n  tabs_scroll_min_duration:         .5,\n  scroll_button_fade_duration:      .2,\n  scroll_button_fade_delay:         .5,\n  tab_content_padding_v:            12,\n  tab_menu_content_padding_v:       6,\n  tab_indicator_height:             2,\n  scrollbar_offset:                 20,\n  scroll_button_opacity:            .7,\n  label_opacity:                    .7,\n\n  tab_label_line_height,\n  tab_label_vertical_offset:        tab_label_line_height - fontSize,\n  tab_label_transition_property:    \"opacity, color, backgroundColor\",\n \n  color_light:                      \"inherit\",\n  color_light_selected:             rgba(vars.color_primary),\n  color_light_selected_background:  \"transparent\",\n  color_light_tab_indicator:        rgba(vars.color_primary),\n  color_light_icon:                 iconButtonVars.color_light,\n \n  color_dark:                       \"inherit\",\n  color_dark_selected:              rgba(vars.color_primary),\n  color_dark_selected_background:   \"transparent\",\n  color_dark_tab_indicator:         rgba(vars.color_primary),\n  color_dark_icon:                  iconButtonVars.color_dark\n};\n","import buttonClasses from \"./button\";\n\nexport default {\n  component:            \"pe-tabs\",\n\n  // elements\n  indicator:            \"pe-tabs__indicator\",\n  scrollButton:         \"pe-tabs__scroll-button\",\n  scrollButtonAtEnd:    \"pe-tabs__scroll-button-end\",\n  scrollButtonAtStart:  \"pe-tabs__scroll-button-start\",\n  scrollButtonOffset:   \"pe-tabs__scroll-button-offset\",\n  tab:                  \"pe-tabs__tab\",\n  tabContent:           \"pe-tabs__tab-content\",\n  tabRow:               \"pe-tabs__row\",\n\n  // states\n  activeSelectable:     \"pe-tabs__active--selectable\",\n  isAtEnd:              \"pe-tabs--end\",\n  isAtStart:            \"pe-tabs--start\",\n  isAutofit:            \"pe-tabs--autofit\",\n  isMenu:               \"pe-tabs--menu\",\n  scrollable:           \"pe-tabs--scrollable\",\n  compactTabs:          \"pe-tabs--compact\",\n  tabHasIcon:           \"pe-tabs__tab---icon\",\n  tabRowCentered:       \"pe-tabs__row--centered\",\n  tabRowIndent:         \"pe-tabs__row--indent\",\n\n  // lookup\n  label:                buttonClasses.label\n};","\nexport default {\n  base:       \"pe-button\",\n  component:  \"pe-button pe-text-button\",\n\n  // elements\n  content:    \"pe-button__content\",\n  focus:      \"pe-button__focus\",\n  label:      \"pe-button__label\",\n  wash:       \"pe-button__wash\",\n\n  // states\n  borders:    \"pe-button--borders\",\n  disabled:   \"pe-button--disabled\",\n  focused:    \"pe-button--focus\",\n  inactive:   \"pe-button--inactive\",\n  selected:   \"pe-button--selected\",\n};\n","import { filterSupportedAttributes } from \"polythene-core\";\nimport { isTouch, subscribe, unsubscribe } from \"polythene-core\";\nimport { scrollTo } from \"polythene-utilities\";\nimport vars from \"./vars\";\nimport classes from \"polythene-css-classes/tabs\";\n\nconst whenCreateDone = () => Promise.resolve();\n\nconst getNewIndex = (index, tabs) => {\n  const minTabIndex = 0;\n  const maxTabIndex = tabs.length - 1;\n  return {\n    backward: Math.max(index - 1, minTabIndex),\n    forward: Math.min(index + 1, maxTabIndex)\n  };\n};\n\nconst handleScrollButtonClick = (state, attrs, e, direction) => {\n  e.stopPropagation();\n  e.preventDefault();\n  const currentTabIndex = state.selectedTabIndex();\n  const newIndex = getNewIndex(currentTabIndex, state.tabs)[direction];\n  if (newIndex !== currentTabIndex) {\n    setSelectedTab(state, attrs, newIndex, true);\n  } else {\n    scrollToTab(state, newIndex);\n  }\n};\n\n/*\nMoves the first tab to the left so that the text label is as position 0. \n*/\nconst alignToTitle = (state) => {\n  const firstTab = state.tabs[0].dom;\n  const firstInnerLabel = firstTab.querySelector(`.${classes.label} span`);\n  const firstOuterLabelWidth = firstTab.getBoundingClientRect().width;\n  const firstInnerLabelWidth = firstInnerLabel.getBoundingClientRect().width;\n  const firstTabOffset = (firstOuterLabelWidth - firstInnerLabelWidth) / 2;\n  firstTab.style.marginLeft = `${-firstTabOffset}px`;\n};\n\nconst createRightButtonOffset = (state) => {\n  // add padding to right so that last item is not hidden behind scroll button\n  const scrollButtonAtEndWidth = state.scrollButtons[\"end\"].getBoundingClientRect().width;\n  const scrollButtonOffsetEl = state.tabsEl.querySelector(`.${classes.scrollButtonOffset}`);\n  scrollButtonOffsetEl.style.width = `${scrollButtonAtEndWidth}px`;\n};\n\nconst scrollToTab = (state, tabIndex) => {\n  const tabs = state.tabs;\n  const scroller = state.scrollerEl;\n  // Scroll to position of selected tab\n  const tabLeft = tabs.slice(0, tabIndex).reduce((totalWidth, tabData) =>\n    totalWidth + tabData.dom.getBoundingClientRect().width, 0);\n  // Tabs at the far right will not fully move to the left\n  // because the scrollable row will stick to the right \n  // to get the max scroll left, we subtract the visible viewport from the scroll width\n  const scrollerWidth = scroller.getBoundingClientRect().width; // frame width\n  const scrollingWidth = scroller.scrollWidth;\n  const maxScroll = scrollingWidth - scrollerWidth;\n  const left = Math.min(tabLeft, maxScroll);\n  const currentLeft = scroller.scrollLeft;\n  if (currentLeft !== left) {\n    const duration = Math.abs(currentLeft - left) / vars.tabs_scroll_speed;\n    const delaySeconds = vars.tabs_scroll_delay || 0;\n    setTimeout(() => {\n      scrollTo({\n        element: scroller,\n        to: left,\n        duration: Math.max(vars.tabs_scroll_min_duration, duration),\n        direction: \"horizontal\"\n      });\n    }, delaySeconds * 1000);\n  }\n};\n\nconst updateScrollButtons = state => {\n  const scrollerEl = state.scrollerEl;\n  const scrollLeft = scrollerEl.scrollLeft;\n  const currentTabIndex = state.selectedTabIndex();\n  const tabsEl = state.tabsEl;\n  const minTabIndex = 0;\n  const maxTabIndex = state.tabs.length - 1;\n  const isAtStart = (scrollerEl.scrollLeft === 0) && (currentTabIndex === minTabIndex);\n  const isAtEnd = (scrollLeft >= (scrollerEl.scrollWidth - tabsEl.getBoundingClientRect().width - 1)) && (currentTabIndex === maxTabIndex);\n  state.scrollButtonStates.start = !isAtStart;\n  state.scrollButtonStates.end = !isAtEnd;\n};\n\nconst animateIndicator = (selectedTabEl, animate, state) => {\n  const parentRect = state.tabsEl.getBoundingClientRect();\n  const rect = selectedTabEl.getBoundingClientRect();\n  const style = state.tabIndicatorEl.style;\n  const translateX = rect.left - parentRect.left + state.scrollerEl.scrollLeft;\n  const transformCmd = `translate(${translateX}px, 0)`;\n  const duration = animate ? vars.indicator_slide_min_duration : 0;\n  // use width instead of scale to please IE10\n  style.width = rect.width + \"px\";\n  style[\"transition-duration\"] = duration + \"s\";\n  style.transform = transformCmd;\n};\n\nconst setSelectedTab = (state, attrs, index, animate) => {\n  state.selectedTabIndex(index);\n  if (!state.tabs.length) return;\n  const selectedTabEl = state.tabs[index].dom;\n  if (selectedTabEl && state.tabIndicatorEl && state.tabsEl) {\n    animateIndicator(selectedTabEl, animate, state);\n  }\n  if (state.managesScroll) {\n    updateScrollButtons(state);\n    scrollToTab(state, index);\n  }\n  if (attrs.onChange) {\n    attrs.onChange({\n      index,\n      options: state.tabs[index].attrs,\n      el: selectedTabEl\n    });\n  }\n};\n\nconst sortByLargestWidth = (a, b) =>\n  a < b\n    ? 1\n    : a > b\n      ? -1\n      : 0;\n\nexport const getInitialState = (vnode, createStream) => {\n  const attrs = vnode.attrs;\n  const selectedTabIndex = createStream(vnode.attrs.selectedTab || 0);\n  const registerTabButton = state => (index, data) => state.tabs[index] = data;\n  const registerScrollButton = state => (position, dom) => state.scrollButtons[position] = dom;\n  return {\n    tabsEl:              undefined,\n    scrollerEl:          undefined,\n    tabs:                [], // {data, el}\n    tabRow:              undefined,\n    tabIndicatorEl:      undefined,\n    selectedTabIndex,\n    previousSelectedTab: undefined,\n    managesScroll:       attrs.scrollable && !isTouch,\n    scrollButtonStates: {\n      start: false,\n      end: false\n    },\n    scrollButtons: {\n      start: undefined,\n      end: undefined\n    },\n    registerTabButton,\n    registerScrollButton,\n    cleanUp: undefined, // set in onMount\n    redrawOnUpdate: createStream.merge([selectedTabIndex])\n  };\n};\n\nexport const onMount = vnode => {\n  const dom = vnode.dom;\n  const state = vnode.state;\n  const attrs = vnode.attrs;\n\n  state.tabsEl = dom;\n  if (!attrs.hideIndicator) {\n    state.tabIndicatorEl = dom.querySelector(`.${classes.indicator}`);\n  }\n  state.scrollerEl = dom.querySelector(`.${classes.tabRow}`);\n\n  // A promise can't resolve during the oncreate loop\n  // The Mithril draw loop is synchronous - there is no delay between one this oncreate and the tab button's oncreate\n  whenCreateDone().then(() => {\n    if (state.tabs && attrs.largestWidth) {\n      const widths = state.tabs.map(tabData => tabData.dom.getBoundingClientRect().width);\n      const largest = widths.sort(sortByLargestWidth)[0];\n      state.tabs.forEach(tabData => tabData.dom.style.width = largest + \"px\");\n    }\n    // Align first scrollable tab to title\n    if (attrs.scrollable) {\n      alignToTitle(state);\n    }\n    // Handle scroll\n    if (state.managesScroll) {\n      createRightButtonOffset(state);\n    }\n    setSelectedTab(state, attrs, state.selectedTabIndex(), false);\n  });\n\n  const onResize = () =>\n    setSelectedTab(state, attrs, state.selectedTabIndex(), false);\n\n  subscribe(\"resize\", onResize),\n\n  state.cleanUp = () => (\n    unsubscribe(\"resize\", onResize)\n  );\n};\n\nexport const onUnMount = ({ state }) =>\n  state.cleanUp();\n\nexport const createProps = (vnode, { keys: k }) => {\n  const state = vnode.state;\n  const attrs = vnode.attrs;\n  const autofit = attrs.scrollable || attrs.centered\n    ? false\n    : attrs.autofit\n      ? true\n      : false;\n\n  // Keep selected tab up to date\n  if (attrs.selectedTab !== undefined && state.previousSelectedTab !== attrs.selectedTab) {\n    setSelectedTab(state, attrs, attrs.selectedTab, true);\n  }\n  state.previousSelectedTab = attrs.selectedTab;\n\n  return Object.assign(\n    {},\n    filterSupportedAttributes(attrs),\n    {\n      className: [\n        classes.component,\n        attrs.scrollable ? classes.scrollable : null,\n        state.selectedTabIndex === 0 ? classes.isAtStart : null,\n        state.selectedTabIndex === state.tabs.length - 1 ? classes.isAtEnd : null,\n        attrs.activeSelected ? classes.activeSelectable : null,\n        autofit ? classes.isAutofit : null,\n        attrs.compact ? classes.compactTabs : null,\n        attrs.menu ? classes.isMenu : null,\n        attrs.tone === \"dark\" ? \"pe-dark-tone\" : null,\n        attrs.tone === \"light\" ? \"pe-light-tone\" : null,\n        attrs.className || attrs[k.class],\n      ].join(\" \")\n    }\n  );\n};\n\nexport const createContent = (vnode, { renderer: h, keys: k, Tab, ScrollButton }) => {\n  const state = vnode.state;\n  const attrs = vnode.attrs;\n\n  const buttons = attrs.content\n    ? attrs.content\n    : attrs.tabs\n      ? attrs.tabs\n      : attrs.children || vnode.children || [];\n\n  if (buttons.length === 0) {\n    console.error(\"No tabs specified\"); // eslint-disable-line no-console\n  }\n\n  const tabRowButtons = buttons.map((buttonOpts = {}, index) => {\n    const buttonOptsCombined = Object.assign(\n      {},\n      buttonOpts,\n      {\n        // These options can be overridden by `all`\n        selected: index === state.selectedTabIndex(),\n        animateOnTap: (attrs.animateOnTap !== false) ? true : false\n      },\n      attrs.all,\n      {\n        // Internal options, should not get overridden\n        index,\n        key: `tab-${index}`,\n        register: state.registerTabButton(state),\n        onSelect: () =>\n          setSelectedTab(state, attrs, index, attrs.noIndicatorSlide ? false : true)\n      }\n    );\n    return h(Tab, buttonOptsCombined);\n  });\n\n  const tabRow = attrs.scrollable\n    ? tabRowButtons.concat([\n      // offset for right scroll button\n      h(\"div\",\n        {\n          key: \"offset\",\n          className: classes.scrollButtonOffset\n        }\n      )\n    ])\n    : tabRowButtons;\n\n  let scrollButtonAtStart, scrollButtonAtEnd;\n  if (attrs.scrollable) {\n    scrollButtonAtStart = h(ScrollButton, Object.assign(\n      {},\n      {\n        key: \"backward\",\n        icon: attrs.scrollIconBackward,\n        className: classes.scrollButtonAtStart,\n        position: \"start\",\n        register: state.registerScrollButton(state),\n        events: { [k.onclick]: e => handleScrollButtonClick(state, attrs, e, \"backward\") }\n      }\n    ));\n    scrollButtonAtEnd = h(ScrollButton, Object.assign(\n      {},\n      {\n        key: \"forward\",\n        icon: attrs.scrollIconForward,\n        className: classes.scrollButtonAtEnd,\n        position: \"end\",\n        register: state.registerScrollButton(state),\n        events: { [k.onclick]: e => handleScrollButtonClick(state, attrs, e, \"forward\") }\n      }\n    ));\n  }\n\n  const tabIndicator = attrs.hideIndicator\n    ? null\n    : h(\"div\",\n      {\n        key: \"indicator\",\n        className: classes.indicator\n      }\n    );\n\n  return [\n    attrs.scrollable ? scrollButtonAtStart : null,\n    h(\"div\",\n      {\n        key: \"tabrow\",\n        className: [\n          classes.tabRow,\n          attrs.centered ? classes.tabRowCentered : null,\n          attrs.scrollable ? classes.tabRowIndent : null\n        ].join(\" \")\n      },\n      [\n        tabRow,\n        tabIndicator\n      ]\n    ),\n    attrs.scrollable ? scrollButtonAtEnd : null\n  ];\n};\n\n","import classes from \"polythene-css-classes/tabs\";\n\n// Don't export 'element': it will be the wrapped Button component (set in polythene-xxx-tabs/tab)\n\nexport const onMount = vnode => {\n  const dom = vnode.dom;\n  if (!dom) {\n    return;\n  }\n  const attrs = vnode.attrs;\n  attrs.register(attrs.index, {\n    attrs,\n    dom\n  });\n};\n\nexport const createProps = (vnode, { renderer: h, keys: k, Icon }) => {\n  const attrs = vnode.attrs;\n  // Let internal onclick function co-exist with passed button option\n  attrs.events = attrs.events || {};\n  attrs.events[k.onclick] = attrs.events[k.onclick] || (() => {});\n  return Object.assign(\n    {},\n    attrs,\n    {\n      content: h(\"div\",\n        { className: classes.tabContent },\n        [\n          attrs.icon ? h(Icon, attrs.icon) : null,\n          attrs.label\n            ? h(\"div\",\n              { className: classes.label },\n              h(\"span\", attrs.label)\n            )\n            : null,\n        ]),\n      className: [\n        classes.tab,\n        attrs.icon && attrs.label ? classes.tabHasIcon : null,\n        attrs.className || attrs[k.class],\n      ].join(\" \"),\n      selected: attrs.selected,\n      wash: false,\n      ripple: true,\n      events: Object.assign(\n        {},\n        attrs.events,\n        {\n          [k.onclick]: e => {\n            attrs.onSelect();\n            attrs.events[k.onclick](e);\n          }\n        }\n      )\n    }\n  );\n};\n\nexport const createContent = () => null;\n","import classes from \"polythene-css-classes/tabs\";\n\n// Don't export 'element': it will be the wrapped IconButton component (set in polythene-xxx-tabs/scroll-button)\n\nconst arrowBackward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\\\"/></svg>\";\nconst arrowForward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\\\"/></svg>\";\n\nexport const onMount = vnode => {\n  const dom = vnode.dom;\n  if (!dom) {\n    return;\n  }\n  const attrs = vnode.attrs;\n  attrs.register(attrs.position, dom);\n};\n\nexport const createProps = (vnode, { renderer: h, keys: k }) => {\n  const attrs = vnode.attrs;\n  const icon = attrs.position === \"start\"\n    ? attrs.icon || { svg: { content: h.trust(arrowBackward) } }\n    : attrs.icon || { svg: { content: h.trust(arrowForward) } };\n  return {\n    className: [\n      classes.scrollButton,\n      attrs.className || attrs[k.class]\n    ].join(\" \"),\n    icon,\n    ripple: { center: true },\n    events: attrs.events,\n  };\n};\n"],"names":["rgba","colorStr","fontSize","buttonVars","font_size","tab_label_line_height","vars","unit_indent","color_primary","iconButtonVars","color_light","color_dark","label","whenCreateDone","Promise","resolve","getNewIndex","index","tabs","maxTabIndex","length","Math","max","min","handleScrollButtonClick","state","attrs","e","direction","stopPropagation","preventDefault","currentTabIndex","selectedTabIndex","newIndex","alignToTitle","firstTab","dom","firstInnerLabel","querySelector","classes","firstTabOffset","getBoundingClientRect","width","style","marginLeft","createRightButtonOffset","scrollButtonAtEndWidth","scrollButtons","tabsEl","scrollButtonOffset","scrollToTab","tabIndex","scroller","scrollerEl","tabLeft","slice","reduce","totalWidth","tabData","scrollerWidth","maxScroll","scrollWidth","left","currentLeft","scrollLeft","duration","abs","tabs_scroll_speed","delaySeconds","tabs_scroll_delay","tabs_scroll_min_duration","updateScrollButtons","isAtStart","isAtEnd","scrollButtonStates","start","end","animateIndicator","selectedTabEl","animate","parentRect","rect","tabIndicatorEl","transformCmd","indicator_slide_min_duration","transform","setSelectedTab","managesScroll","onChange","sortByLargestWidth","a","b","getInitialState","vnode","createStream","selectedTab","registerTabButton","data","registerScrollButton","position","undefined","scrollable","isTouch","merge","onMount","hideIndicator","indicator","tabRow","then","largestWidth","largest","map","sort","forEach","onResize","cleanUp","unsubscribe","onUnMount","createProps","k","keys","autofit","centered","previousSelectedTab","_extends","filterSupportedAttributes","component","activeSelected","activeSelectable","isAutofit","compact","compactTabs","menu","isMenu","tone","className","class","join","createContent","h","renderer","Tab","ScrollButton","buttons","content","children","error","tabRowButtons","buttonOpts","buttonOptsCombined","animateOnTap","all","noIndicatorSlide","concat","scrollButtonAtStart","scrollButtonAtEnd","scrollIconBackward","onclick","scrollIconForward","tabIndicator","tabRowCentered","tabRowIndent","register","Icon","events","tabContent","icon","tab","tabHasIcon","selected","onSelect","svg","trust","scrollButton","center"],"mappings":"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"}